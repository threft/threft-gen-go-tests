package list

// This complete file is to be generated by the thrift4go generator.
// The current list is actually a "generic/dynamic" list implemented in the thrift4go library.
// 		it makes heavy use of type assertion and stores all values as `interface{}`
// The goal of this sub-project (list-tryout) is to provide an example generated-code and use-cases for a new aproach to thrift lists.
// 		this is not implemented yet, and just in designing phase.
// This file only contains code for the list<i32>, as required in the thrift file lists.thrift
// The filename for this code is the combination of the word "list" and the go typename of the generated list, capitalized.
// For example: `list<i32>` becomes `listInt32.go`
// 				`list<string>` becomes `listString.go`
// 				`list<MyStruct>` becomes `listMyStruct.go`
// 				`list<myEnum>` becomes `listMyEnum.go`
// This code is heavily based on the existing TList code in /thriftgo/lib/go/src/thift/tlist.go

import ()

// Name for the struct is "List" plus, the go typename of te object it is holding capitalized.
//++ TODO: This struct should probably implement an interface `TList` that required methods to provide metadata for easy serialization (or those parts are generated too).
type ListInt32 struct {
	list []int32
}

func NewListInt32() *ListInt32 {
	return &ListInt32{list: make([]int32, 0)}
}

func (l *ListInt32) Len() int {
	return len(l.list)
}

func (l *ListInt32) At(index int) int32 {
	return l.list[index]
}

func (l *ListInt32) Set(index int, data int32) {
	if len(l.list) >= index {
		l.list[index] = data
	} else {
		l.list = append(l.list, data)
	}
}

func (l *ListInt32) Push(data int32) {
	l.list = append(l.list, data)
}

func (l *ListInt32) Pop() int32 {
	var popval int32
	popval, l.list = l.list[len(l.list)-1], l.list[:len(l.list)-1]
	return popval
}

func (l *ListInt32) Swap(indexA, indexB int) {
	l.list[indexB], l.list[indexA] = l.list[indexA], l.list[indexB]
}

func (l *ListInt32) Insert(index int, data int32) {
	newl := make([]int32, 1)
	newl[0] = data
	l.list = append(l.list[:index], append(newl, l.list[index:]...)...)
}

func (l *ListInt32) Delete(index int) {
	l.list = append(l.list[:index], l.list[index+1:]...)
}

func (l *ListInt32) Contains(data int32) bool {
	return l.IndexOf(data) >= 0
}

func (l *ListInt32) Less(i, j int) bool {
	return l.list[i] < l.list[j]
}

func (l *ListInt32) Iter() <-chan int32 {
	c := make(chan int32)
	go l.iterate(c)
	return c
}

func (l *ListInt32) iterate(c chan<- int32) {
	for _, elem := range l.list {
		c <- elem
	}
	close(c)
}

// Returns the index of the first occurence of the given data in the list.
// -1 if data does not occur in the list
func (l *ListInt32) IndexOf(data int32) int {
	//++ Use this for nil-able type's
	// if data == nil {
	// 	size := len(l.list)
	// 	for i := 0; i < size; i++ {
	// 		if l.list[i] == nil {
	// 			return i
	// 		}
	// 	}
	// 	return -1
	// }

	size := len(l.list)

	//++ Use for bytes
	// if p.elemType == BINARY {
	// 	for i := 0; i < size; i++ {
	// 		if bytes.Compare(data.([]byte), l.list[i].([]byte)) == 0 {
	// 			return i
	// 		}
	// 	}
	// 	return -1
	// }

	//++ Use for basetype or enum (?!?!?!)
	// if p.elemType.IsBaseType() || p.elemType.IsEnum() {
	// 	for i := 0; i < size; i++ {
	// 		if data == l.list[i] {
	// 			return i
	// 		}
	// 	}
	// 	return -1
	// }

	//++ Use for interface{} (!?!?!?!)
	// if cmp, ok := data.(EqualsOtherInterface); ok {
	// 	for i := 0; i < size; i++ {
	// 		if cmp.Equals(l.list[i]) {
	// 			return i
	// 		}
	// 	}
	// 	return -1
	// }

	//++ Use for map/set/list/sruct
	// switch p.elemType {
	// case MAP:
	// 	if cmp, ok := data.(EqualsMap); ok {
	// 		for i := 0; i < size; i++ {
	// 			v := l.list[i]
	// 			if v == nil {
	// 				continue
	// 			}
	// 			if cmp.Equals(v.(TMap)) {
	// 				return i
	// 			}
	// 		}
	// 		return -1
	// 	}
	// case SET:
	// 	if cmp, ok := data.(EqualsSet); ok {
	// 		for i := 0; i < size; i++ {
	// 			v := l.list[i]
	// 			if v == nil {
	// 				continue
	// 			}
	// 			if cmp.Equals(v.(TSet)) {
	// 				return i
	// 			}
	// 		}
	// 		return -1
	// 	}
	// case LIST:
	// 	if cmp, ok := data.(EqualsList); ok {
	// 		for i := 0; i < size; i++ {
	// 			v := l.list[i]
	// 			if v == nil {
	// 				continue
	// 			}
	// 			if cmp.Equals(v.(TList)) {
	// 				return i
	// 			}
	// 		}
	// 		return -1
	// 	}
	// case STRUCT:
	// 	if cmp, ok := data.(EqualsStruct); ok {
	// 		for i := 0; i < size; i++ {
	// 			v := l.list[i]
	// 			if v == nil {
	// 				continue
	// 			}
	// 			if cmp.Equals(v.(TStruct)) {
	// 				return i
	// 			}
	// 		}
	// 		return -1
	// 	}
	// }

	for i := 0; i < size; i++ {
		if l.list[i] == data {
			return i
		}
	}
	return -1
}

// This abstraction method is probably not required anymore
// Or it should be replaced by generated code with == operator as int32 is a base type
// func (l *ListInt32) Equals(other int32) bool {
// 	c, cok := p.CompareTo(other)
// 	return cok && c == 0
// }

// This abstraction method is probably not required anymore
// Or it should be replaced by generated code with > < or == operator as int32 is a base type
// func (l *ListInt32) CompareTo(other int32) (int, bool) {
// 	return TType(LIST).Compare(p, other)
// }
